generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["referentialIntegrity", "interactiveTransactions"]
}

// TiDB is highly compatible with the MySQL 5.7 protocol and the common features 
// and syntax of MySQL 5.7.
//
// TiDB currently does not support foreign key constraints. If you need to use the feature of 
// referential integrity, you can use the application layer implementation of Prisma.
//
// Reference: https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-integrity#handling-the-referential-integrity-in-prisma
// Related Issue [WIP]: https://github.com/pingcap/tidb/issues/18209
// 
// More descriptions about MySQL compatibility:
// Refercene: https://docs.pingcap.com/tidb/dev/mysql-compatibility

datasource db {
  provider             = "mysql"
  url                  = env("DATABASE_URL")
  referentialIntegrity = "prisma"
}

// 
// https://www.prisma.io/docs/concepts/components/prisma-schema/data-model


model Author {
  id        BigInt       @id
  name      String       @db.VarChar(100)
  gender    Boolean?
  birthYear Int?         @map("birth_year") @db.SmallInt
  deathYear Int?         @map("death_year") @db.SmallInt
  books     BookAuthor[]

  @@map("authors")
}

model BookAuthor {
  book     Book   @relation(fields: [bookId], references: [id])
  bookId   BigInt @map("book_id")
  author   Author @relation(fields: [authorId], references: [id])
  authorId BigInt @map("author_id")

  @@id([bookId, authorId])
  @@map("book_authors")
}

model Book {
  id          BigInt       @id
  title       String       @db.VarChar(100)
  type        BookType
  publishedAt DateTime     @map("published_at") @db.DateTime(0)
  stock       Int          @default(0)
  price       Decimal      @default(0.0) @db.Decimal(15, 2)
  authors     BookAuthor[]
  ratings     Rating[]
  orders      Order[]

  @@map("books")
}

model Order {
  id        BigInt   @id @default(autoincrement())
  book      Book     @relation(fields: [bookId], references: [id])
  bookId    BigInt   @map("book_id")
  user      User     @relation(fields: [userId], references: [id])
  userId    BigInt   @map("user_id")
  quality   Int      @db.TinyInt
  orderedAt DateTime @default(now()) @map("ordered_at") @db.DateTime(0)

  @@index([bookId])
  @@map("orders")
}

model Rating {
  book    Book     @relation(fields: [bookId], references: [id])
  bookId  BigInt   @map("book_id")
  user    User     @relation(fields: [userId], references: [id])
  userId  BigInt   @map("user_id")
  score   Int      @db.TinyInt
  ratedAt DateTime @default(now()) @map("rated_at") @db.DateTime(0)

  @@id([bookId, userId])
  @@unique([bookId, userId], map: "uniq_book_user_idx")
  @@map("ratings")
}

model User {
  id       BigInt   @id
  balance  Decimal  @default(0.0) @db.Decimal(15, 2)
  nickname String   @unique(map: "nickname") @db.VarChar(100)
  ratings  Rating[]
  orders   Order[]

  @@map("users")
}

// Because special characters cannot be used in the schema definition of the data model,
// we use `_nbsp_` to represent one space and use `_amp_` to represent `&`.

enum BookType {
  Magazine
  Novel
  Life
  Arts
  Comics
  Education_nbsp__amp__nbsp_Reference             @map("Education & Reference")
  Humanities_nbsp__amp__nbsp_Social_nbsp_Sciences @map("Humanities & Social Sciences")
  Science_nbsp__amp__nbsp_Technology              @map("Science & Technology")
  Kids
  Sports

  @@map("books_type")
}
